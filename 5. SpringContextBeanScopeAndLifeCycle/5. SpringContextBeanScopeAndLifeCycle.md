# The Spring context: Bean scopes and life cycle

#### Spring has multiple approaches for creating beans and managing their lifecycle, these approaches are called scopes:
- singleton
- prototype

## Using the singleton bean scope

**Singleton is the default scope of a bean in Spring**

When using singleton scope **you always get the same instance when you refer to a specific bean**, but *you can have more instances of the same type in the Spring context if they have different names*

### Declaring singleton-scoped beans with ```@Bean```

Let's have basic CommentService class
```java
public class CommentService {}
```
We have to create the Configuration class and add a method with ```@Bean``` to create an instance of CommentService to the Spring context
```java
@Configuration
public class ProjectConfig{
    // the bean name would be commentService
    @Bean
    public CommentService commentService() {
        return new CommentService();
    }
}
```
Finally in the main function you could observe that getting twice that bean would result in getting the same instance
```java
public class Main {
    public static void main(String[] args) {
        var c = new AnnotationConfigApplicationContext(ProjectConfig.class);
        var cs1 = c.getBean("commentService", CommentService.class);
        var cs2 = c.getBean("commentService", CommentService.class);
        boolean b1 = cs1 == cs2;
        // this will return true, because they point to the same instance
        System.out.println(b1);   
    }
}
```
**Remember: Spring's default scope approach is always singleton**


### Declaring singleton beans using stereotype annotations

*It is not different when usign stereotype annotations than using ```@Bean``` annotation*

Consider a class design where two services depend on a repository, lets say their names are CommentService and UserService dependant on CommentRepository
```java
// because of @Repository, Spring adds a bean of type CommentRepository to its context
// The bean by default would be singleton, so Spring creates one instance and siignes a name ot it
// the name of the class actually becomest the name of the bean
@Repository
public class CommentRepository {}
```
```java
@Service
public class CommentService {
    // Using @Autowired the class request from Spring to inject a bean of type CommentRepository 
    @Autowired
    private CommentRepository commentRepository;

    public CommentRepository getCommentRepository() {
        return commentRepository;
    }
}
```
```java
@Service
public class UserService {
    // Using @Autowired the class request from Spring to inject a bean of type CommentRepository 
    @Autowired
    private CommentRepository commentRepository;
    
    public CommentRepository getCommentRepository() {
        return commentRepository;
    }
}
```
*The empty class remains empty in this project, because no ```@Bean``` annotations will be used, but the classes annotated with ```@Component``` have to be specified*
```java
@Configuration
@ComponentScan(basePackage= {"services", "repositories"})
public class ProjectConfig {
}
```

### Singleton beans in real-life

Since singleton bean is going to be shared across multiple component of the app, **the most important thing is that his bean must be immutable**

*Otherwise in lets say multhithreaded architecture different threads can access this singleton bean and want to change it, it will happen **race condition***

*Basically a race condition is when multiple threads are trying to changed a shared resource, **synchronization of the threads should happen to prevent that***

Singleton beans aren't designed to be synchronized, they are **used to define an app's backbone class design**

*Synchronizing the thread on a concurrent instance can dramatically affect the app's performance*

**One of the advantages of constructor injection is that it allows the instance to be immutable**

#### Using beans comes down to three points:
- Make an object bean in the Context only if you want Spring to manage it, otherwise dont make it a bean
- One bean should be singleton only if it is immutable, avoid designing singleton beans
- If a bean needs to be immutable, an option could be to use prototype scope

### Using eager and lazy instantions

**Spring's default behavior is to create all the singleton beans when it initializes the context**

**With lazy instantiation, Spring creates each instance the first time someone refers to the bean**

### Eager instantiation example

Let's create an example using eager instantiaton
```java
package service;
@Service 
public class CommentService {
    public CommentService() {
        System.out.println("Comment instance created!");
    }
}
```
```java
@Configuration
@ComponentScan(basePackages = {"services"})
public class ProjectConfig {
}
```
When creating the context inside the main function, CommentService will be instantiated
```java
public class Main {
    public static void main(String[] args) {
        var c = new AnnotationConfigApplicationContext(ProjectConfig.class);
    }
}
```
### Lazy instantiation example

Let's create the lazy instantiation example

Using ```@Lazy``` annotation we instruct Spring to create the bean only when someone uses it

```java
@Service
@Lazy
public class CommentService {
    public CommentService() {
        System.out.println("CommentService instance created!");
    }
}
```
```java
@Configuration
@ComponentScan(basePackages = {"services"})
public class ProjectConfig {
}
```
```java
public class Main {
    public static void main(String[] args) {
        var c = new AnnotationConfigApplicationContext(ProjectConfig.class);
 
        // The output is: System.out.println("CommentService instance created!");
        var service = c.getBean(CommentService.class);                
    }
}
```

### When to use eager and when to use lazy instantiation

**It is better to let the framework instantiate all the beans in the beginning, this way when one instance delegates to another, the second beans already exists in the context**

**In a lazy instantiation, the framework has to first check if the instance exists and eventually create it if it doenst**, but *This could slow the performance a little bit*

## Using the prototype bean scope 

**Every them when a reference to a prototype-scoped bean is requested, Spring creates a new object instance**

**The framework manages the object's type and creates a new instance every time someone requests a reference to the bean**

**To create a prototype scope ```@Scope``` annotation is required**

*With prototype beans, there are no currency problems because each thread that request the bean gets a different instance*

### Declaring prototype-scoped beans with ```@Bean```

Let's create an example
```java
public class CommentService {}
```
```java
@Configuration
public class ProjectConfig {
    @Bean
    @Scope(BeanDefinition.SCOPE_PROTOTYPE)
    public CommentService commentService() {
        return new CommentService();
    }
}
```
```java
public class Main {
    public static void main(String[] args) {
        var c = new AnnotationConfigApplicationContext(ProjectConfig.class);

        //every time the bean is requested, Sprig will create a new instance from the type in the context
        var cs1 = c.getBean("commentService", CommentService.class);
        var cs2 = c.getBean("commentService", CommentService.class);

        // will result to false, since the references are different 
        boolean b1 = cs1 == cs2;    
        System.out.println(b1);     
    }
}
```

### Declaring Prototype-scoped beans using stereotype annotations

We will work on this app

![](https://image2url.com/r2/default/images/1771427627535-49c2e267-f525-489e-91a0-3077fff13a28.png)

```java
package repositories;

@Repository
//@Scope annotations is used over the class to change the scope of the bean
@Scope(BeanDefinition.SCOPE_PROTOTYPE)
public class CommentRepository {
}
```
```java
package services;

@Service
public class CommentService {
 
  @Autowired
  private CommentRepository commentRepository;
 
  public CommentRepository getCommentRepository() {
    return commentRepository;
  }
}
```
```java
@Configuration
@ComponentScan(basePackages = {"services", "repositories"})
public class ProjectConfig {
 
}
```
```java
public class Main {
    public static void main(String[] args) {
        var c = new AnnotationConfigApplicationContext(ProjectConfig.class);
 
        //two different instances
        var s1 = c.getBean(CommentService.class);   
        var s2 = c.getBean(UserService.class);      
 
        boolean b = s1.getCommentRepository() == s2.getCommentRepository();
 
        System.out.println(b);
    }
}
```

### Prototype beans in real-world scenarios

**If you need to have a mutable object like a bean, usingthe prototype scope could be a good option**

**Be careful when injecting a prototype-scoped bean into a singleton-scoped bean. When you do something like that the singleton instance always uses the same prototype instance, which totally destroyes the idea behind protytpe-scoped beans**