# The Spring context: Bean scopes and life cycle

#### Spring has multiple approaches for creating beans and managing their lifecycle, these approaches are called scopes:
- singleton
- prototype

## Using the singleton bean scope

**Singleton is the default scope of a bean in Spring**

When using singleton scope **you always get the same instance when you refer to a specific bean**, but *you can have more instances of the same type in the Spring context if they have different names*

### Declaring singleton-scoped beans with ```@Bean```

Let's have basic CommentService class
```java
public class CommentService {}
```
We have to create the Configuration class and add a method with ```@Bean``` to create an instance of CommentService to the Spring context
```java
@Configuration
public class ProjectConfig{
    // the bean name would be commentService
    @Bean
    public CommentService commentService() {
        return new CommentService();
    }
}
```
Finally in the main function you could observe that getting twice that bean would result in getting the same instance
```java
public class Main {
    public static void main(String[] args) {
        var c = new AnnotationConfigApplicationContext(ProjectConfig.class);
        var cs1 = c.getBean("commentService", CommentService.class);
        var cs2 = c.getBean("commentService", CommentService.class);
        boolean b1 = cs1 == cs2;
        // this will return true, because they point to the same instance
        System.out.println(b1);   
    }
}
```
**Remember: Spring's default scope approach is always singleton**


### Declaring singleton beans using stereotype annotations

*It is not different when usign stereotype annotations than using ```@Bean``` annotation*

Consider a class design where two services depend on a repository, lets say their names are CommentService and UserService dependant on CommentRepository
```java
// because of @Repository, Spring adds a bean of type CommentRepository to its context
// The bean by default would be singleton, so Spring creates one instance and siignes a name ot it
// the name of the class actually becomest the name of the bean
@Repository
public class CommentRepository {}
```
```java
@Service
public class CommentService {
    // Using @Autowired the class request from Spring to inject a bean of type CommentRepository 
    @Autowired
    private CommentRepository commentRepository;

    public CommentRepository getCommentRepository() {
        return commentRepository;
    }
}
```
```java
@Service
public class UserService {
    // Using @Autowired the class request from Spring to inject a bean of type CommentRepository 
    @Autowired
    private CommentRepository commentRepository;
    
    public CommentRepository getCommentRepository() {
        return commentRepository;
    }
}
```
*The empty class remains empty in this project, because no ```@Bean``` annotations will be used, but the classes annotated with ```@Component``` have to be specified*
```java
@Configuration
@ComponentScan(basePackage= {"services", "repositories"})
public class ProjectConfig {
}
```