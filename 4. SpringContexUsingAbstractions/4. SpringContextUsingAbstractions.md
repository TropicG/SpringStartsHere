# Spring Context: Using abstractions

## Implementing the requirement without using a framework

*Right now we will create small working project without using Spring that will contain object implementing interfaces. The idea is to see how these things work without Spring so that later will see how Spring works with abstractions*

*Our small project will be about storing comments in database and showing them to the user in email*

**We refer to object which implement use cases as services**

**When we have object that works directly with a database we call it repository**

**When implementing object whose responsibility is to establish communication with something outside the app, this object is called proxies**

![](https://image2url.com/r2/default/images/1771355930665-6efb88ed-0f56-4616-86a8-0a12ac06fa11.png)

**Remember: Always code to interface, never to implementation, you do not know in the future how to requirement is going to change. It is always better to have coupling with interfaces instead of direct implementations**

Since we will be using application that works with comments, it would be good idea to create a model for the data that the app will use
```java
public record Comment(private String author, private String text);
```
**Classes that model data that is going to be stored in the app are called model**

Let's define the responsibilities of repository
```java
public interface CommentRepository {
    void storeComment(Comment comment);
}
```

In the image above we can see that CommentService object uses CommentRepository's method storeComment in order to store the comment in the Database, let's create an implementation so that we define the storeComment method
```java
public class DBCommentRepository implements CommentRepository{
    @Override
    public void storeComment(Comment comment) {
        // since no actual connection to database will happen, we will only notify that the comment was stored
        System.out.println("Storring comment: "  + comment.text());
    }
}
```
The other responsibility the CommentService will have is to notify the user by email and we will implement interface that will define the behaviour:
```java
public interface CommentNotificationProxy {
    void sendComment(Comment comment);
}
```

implementation of this interface would look like this:
```java
public class EmailCommentNotificationProxy implements CommentNotificationProxy {
    @Override
    public void sendComment(Comment comment) {
        System.out.println("Sending notification for comment: " + comment.getText());
    }
}
```

Finnally, the CommentService class would look like this:
```java
public class CommentService {
    private final CommentRepository commentRepository;
    private final CommentNotificationProxy commentNotificationProxy;

    public CommentService(CommentRepository commentRepository, CommentNotificationProxy commentNotificationProxy) {
        //assigning the dependencies that the service will use
        this.commentRepository = commentRepository;
        this.commentNotificationProxy = commentNotificationProxy;
    }

    public void publishComment(Comment comment) {
        // actual business logic that happens here
        commentRepository.storeComment(comment);
        commentNotificationProxy.sendComment(comment);
    }
}
```
*You can imagine that the in the main class of this application the dependencies have to be created using new operator which is totally against of what Spring is trying to achieve*

## Using dependency injection with abstractions

*In this chapter we will discuss how Spring manages dependency injection when using abstractions as well as learn to decide which object are needed to make Spring aware of*

### Deciding which objects should be part of the Spring context

*It is not necessary to add every object inside the Spring context*

Remember the main reason to add an object to the Spring context is to allow Spring to control it and further augment it with functionalities the framework provides, so the question should be **does this object need to be managed by the framework**

In our case **we need to add the object to the Spring context if it either has a dependency we need to inject from the context or if it is a dependency itself**

Looking at our project **the only class that doesnt have a depdendency or also is not dependency itself is Comment**
#### The following object in our application:
- CommentService has two dependencies: **CommentRepository** and **CommentNoficationProxy**
- DBCommentRepository implements **CommentRepository** and **is a dependency of the CommmentService**
- EmailComentNotificationProxy **implements CommentNotificationProxy** and **is a dependency of the CommentService**

*Why not adding Comment instances? Because adding objects to the Spring context without needing the framework to manage them adds unnecessary complexity to your app, making it more challenging to maintain and less performant*

**We use stereotype annotations for the classes that Spring needs to create instances and add these instances to its context, it doenst make sense to add stereotype annotations on interfaces or abstract classes**

Refactoring the code, we can add ```@Component``` annotations to the dependencies that are going to be used as well as the CommentService class
```java
@Component
public class DBCommentRepository implements CommentRepository {
    @Override
    public void storeComment(Comment comment) {
        System.out.println("Storing comment: " + comment.getText());
    }
}
```

```java
@Component
public class EmailCommentNotificationProxy implements CommentNotificationProxy {
    @Override
    public void sendComment(Comment comment) {
        System.out.println("Sending notification for comment: " + comment.getText());
    }
}
```

```java
@Component 
public class CommentService {
    private final CommentRepository commentRepository;
    private final CommentNotificationProxy commentNotificationProxy;

    // Spring sees the attributes are with interface types and it is smart enough to search in its context for beans created with classes that implement these interface
    // Since there is only one constructor, @Autowired is optional
    public CommentService( CommentRepository commentRepository, CommentNotificationProxy commentNotificationProxy) {
        this.commentRepository = commentRepository;
        this.commentNotificationProxy = commentNotificationProxy;
    }

    public void publishComment(Comment comment) {
        commentRepository.storeComment(comment);
        commentNotificationProxy.sendComment(comment);
    }
}
```
