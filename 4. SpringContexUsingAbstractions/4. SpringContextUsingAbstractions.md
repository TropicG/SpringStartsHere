# Spring Context: Using abstractions

## Implementing the requirement without using a framework

*Right now we will create small working project without using Spring that will contain object implementing interfaces. The idea is to see how these things work without Spring so that later will see how Spring works with abstractions*

*Our small project will be about storing comments in database and showing them to the user in email*

**We refer to object which implement use cases as services**

**When we have object that works directly with a database we call it repository**

**When implementing object whose responsibility is to establish communication with something outside the app, this object is called proxies**

![](https://image2url.com/r2/default/images/1771355930665-6efb88ed-0f56-4616-86a8-0a12ac06fa11.png)

**Remember: Always code to interface, never to implementation, you do not know in the future how to requirement is going to change. It is always better to have coupling with interfaces instead of direct implementations**

Since we will be using application that works with comments, it would be good idea to create a model for the data that the app will use
```java
public record Comment(private String author, private String text);
```
**Classes that model data that is going to be stored in the app are called model**

Let's define the responsibilities of repository
```java
package repositories;

public interface CommentRepository {
    void storeComment(Comment comment);
}
```

In the image above we can see that CommentService object uses CommentRepository's method storeComment in order to store the comment in the Database, let's create an implementation so that we define the storeComment method
```java
package repositories;

public class DBCommentRepository implements CommentRepository{
    @Override
    public void storeComment(Comment comment) {
        // since no actual connection to database will happen, we will only notify that the comment was stored
        System.out.println("Storring comment: "  + comment.text());
    }
}
```
The other responsibility the CommentService will have is to notify the user by email and we will implement interface that will define the behaviour:
```java
package proxies;

public interface CommentNotificationProxy {
    void sendComment(Comment comment);
}
```

implementation of this interface would look like this:
```java
package proxies;

public class EmailCommentNotificationProxy implements CommentNotificationProxy {
    @Override
    public void sendComment(Comment comment) {
        System.out.println("Sending notification for comment: " + comment.getText());
    }
}
```

Finnally, the CommentService class would look like this:
```java
package service;

public class CommentService {
    private final CommentRepository commentRepository;
    private final CommentNotificationProxy commentNotificationProxy;

    public CommentService(CommentRepository commentRepository, CommentNotificationProxy commentNotificationProxy) {
        //assigning the dependencies that the service will use
        this.commentRepository = commentRepository;
        this.commentNotificationProxy = commentNotificationProxy;
    }

    public void publishComment(Comment comment) {
        // actual business logic that happens here
        commentRepository.storeComment(comment);
        commentNotificationProxy.sendComment(comment);
    }
}
```
*You can imagine that the in the main class of this application the dependencies have to be created using new operator which is totally against of what Spring is trying to achieve*

## Using dependency injection with abstractions

*In this chapter we will discuss how Spring manages dependency injection when using abstractions as well as learn to decide which object are needed to make Spring aware of*

### Deciding which objects should be part of the Spring context

*It is not necessary to add every object inside the Spring context*

Remember the main reason to add an object to the Spring context is to allow Spring to control it and further augment it with functionalities the framework provides, so the question should be **does this object need to be managed by the framework**

In our case **we need to add the object to the Spring context if it either has a dependency we need to inject from the context or if it is a dependency itself**

Looking at our project **the only class that doesnt have a depdendency or also is not dependency itself is Comment**
#### The following object in our application:
- CommentService has two dependencies: **CommentRepository** and **CommentNoficationProxy**
- DBCommentRepository implements **CommentRepository** and **is a dependency of the CommmentService**
- EmailComentNotificationProxy **implements CommentNotificationProxy** and **is a dependency of the CommentService**

*Why not adding Comment instances? Because adding objects to the Spring context without needing the framework to manage them adds unnecessary complexity to your app, making it more challenging to maintain and less performant*

**We use stereotype annotations for the classes that Spring needs to create instances and add these instances to its context, it doenst make sense to add stereotype annotations on interfaces or abstract classes**

Refactoring the code, we can add ```@Component``` annotations to the dependencies that are going to be used as well as the CommentService class
```java
package repositories;

@Component
public class DBCommentRepository implements CommentRepository {
    @Override
    public void storeComment(Comment comment) {
        System.out.println("Storing comment: " + comment.getText());
    }
}
```

```java
package proxies;

@Component
public class EmailCommentNotificationProxy implements CommentNotificationProxy {
    @Override
    public void sendComment(Comment comment) {
        System.out.println("Sending notification for comment: " + comment.getText());
    }
}
```

```java
package service;

@Component 
public class CommentService {
    private final CommentRepository commentRepository;
    private final CommentNotificationProxy commentNotificationProxy;

    // Spring sees the attributes are with interface types and it is smart enough to search in its context for beans created with classes that implement these interface
    // Since there is only one constructor, @Autowired is optional
    public CommentService( CommentRepository commentRepository, CommentNotificationProxy commentNotificationProxy) {
        this.commentRepository = commentRepository;
        this.commentNotificationProxy = commentNotificationProxy;
    }

    public void publishComment(Comment comment) {
        commentRepository.storeComment(comment);
        commentNotificationProxy.sendComment(comment);
    }
}
```
Dont forget to tell Spring where to find those classes annotated with ```@Component``` 
```java
@Configuration
@ComponentScan(basePackages = {"proxies", "services", "repositories"})
public class ProjectConfiguration{

}
```

Looking at the main function of the application it would look like this
```java
public class Main {
    public static void main(String[] args) {
        var context = new AnnotationConfigApplicationContext(ProjectConfiguration.class);

        Comment comment = new Comment("TropicGamerMC", "very positive comment");

        // getting the instance from the context, Spring will autowire its dependencies automatically
        CommentService commentService = context.getBean(CommentService.class);
        commentService.publishComment(comment);
    }
}
```

*You could observe that when using DI feature, the instance of the CommentService as well as for its dependencies wasnt't created, Spring took care for it*

### Choosing what to auto-wire from multiple implementations of an abstraction

Imagine if we had two beans created with two different classes that implement the CommentNotificationProxy interface, how could Spring decide which implementation to use?

#### Fortunately for us, Spring gives you the option to go with two different approaches:
- Using the ```@Primary``` annotation to mark one of the beans for implementation as the default
- Using the ```@Qualifer``` annotation to name a bean and then refer to it by its name for DI

*For example if we create a new bean implementing CommentNotificationProxy without ```@Primary``` or ```@Qualifer```, the application will return exception because Spring doesn't know which bean to choose*

### Marking an implementation as default for injection with ```@Primary```

```@Primary``` can be added near the ```@Component``` annotation 
```java
@Component
@Primary
public class CommentPushNotificationProxy implements CommentNotificationProxy {
    @Override
    public void sendComment(Comment comment) {
        System.out.println("Sending push notification for comment: " + comment.text());
    }
}
```

### Naming implementation for depedency injection with ```@Qualifier```

```@Qualifier``` can be used to specify the name of the bean in the Spring Context
```java
@Component
@Qualifer("PUSH")
public class CommentPushNotificationProxy implements CommentNotificationProxy {
    //code
}
```
When you want Spring to inject one of these, you just need to specify the implementation's name using the ```@Qualifer``` annotation again
```java
@Component
public class CommentService {
    private final CommentRepositor commentRepository;
    private final CommentNotificationProxy commentNotificationProxy;

    // Spring will inject the bean with the name "PUSH" to the CommentService
    public CommentService(CommentRepository commentRepository, @Qualifer("PUSH") CommentNotificationProxy commentNotificationProxy) {
        this.commentRepository = commentRepository;
        this.commentNotificationProxy = commentNotificationProxy;
    } 

    //other code
}
```

## Focusing on object responsibilities with stereotype annotations

Using ```@Component``` is generic and gives no details about the responsibility of the object you are implementing

**The services are the objects with the responsibility of implementing the use cases, while repositories are the objects managing the data persistance**

Spring offers us the ```@Service``` annotation to mark a component that takes the responsibility of a service and the ```@Repository``` annotation to mark a component that implements a repository responsibilities

From the application above CommentService could be marked with ```@Service``` instead of ```@Component``` 
```java
@Service
public class CommentService{

}
```
Similarly, we could mark the repository class as ```@Repository```
```java
@Repository
public class DBCommentRepository implements CommentRepository {
    // code
}
```

*Remember this change of annotations doesn't change the logic or the interal Spring Context logic, those annotations are used so that other developers can understand what are the reponsibilities of the classes*