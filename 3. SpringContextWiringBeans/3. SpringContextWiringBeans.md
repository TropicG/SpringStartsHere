# The Spring context: Wiring beans 

In apps , we need to refer from one bean to another  **by telling Spring to provide a reference to an instance from its context**

#### There are multiple ways to establish relationship between the beans:
- Link the beans by directly calling the methods that create them *(also called wiring)*
- Enable Spring to provide us a value using a method parameter *(also called auto-wiring)*
- Using Dependency Injection principle with ```@Autowired```

## Implementing relationships among beans defined in the configuration file

*This section is about implementing relationship between two beeans defined in the configuration class annotating methods with the ```@Bean``` annotation*

*In this section we will work with the classes Person and Parrot, the objective is to connect the Parrot with the Person, in other words establish a relationship between them*

*The Parrot and the Person have 'has-A' relationship*
![](https://image2url.com/r2/default/images/1771333694119-5732fbf1-1c10-48a0-87e3-4261426536a3.png)

Inserting the two instances in the Spring Context would look like this
```java
@Configuration
public class ProjectConfig {
    @Bean
    public Parrot parrot() {
        Parrot p = new Parrot();
        p.setName("Deni");
        return p;
    }

    @Bean
    public Person person() {
        Person p = new Person();
        p.setName("Koko");
        return p;
    }
}
```
### Wiring the beans using a direct method call between the @Bean methods

The way to achieve this wiring is to **call one bean defining method from another one in the configuration class**
```java
@Configuration
public class ProjectConfig {
    @Bean
    public Parrot parrot() {
        Parrot p = new Parrot();
        p.setName("Koko");
        return p;
    }

    @Bean
    public Person person() {
        Person p = new Person();
        p.setName("Deni");
        // If the parrot instance doesnt exists in the context, Spring will create it and add it 
        // otherwise Spring will take directly the instance of the context to connect it with the Human class
        p.setParrot(parrot());
        return p;
    }
}
```

### Wiring the beans using the @Bean annotated method's parameters 

Instead of directly calling the method that defines the bean we wish to refer to, **we add a parameter to the method of the corresponding type of object, and we rely on Spring to provide us a value through that parameter**
```java
@Configuration
public class ProjectConfig {
    @Bean
    public Parrot parrot() {
        Parrot p = new Parrot();
        p.setName("Koko");
        return p;
    }

    @Bean
    // Spring is instructed to provide a beam from its context by defining a parameter for the method
    public Person person(Parrot parrot) {
        Person p = new Person();
        p.setName("Deni");
        // The parrot attributed is set using the reference Spring provided
        p.setParrot(parrot);
        return p;
    }
}

```
Spring sets a particular value into the parameter of the person() method when calling it and resolves a dependency of this method.

DI *(also knowns as Dependency Injection)* is a technique involving the framework setting a value into a specific field or parameter


## Using the ```@Autowired``` annotation to inject beans 
When using ```@Autowired``` annotation, we mark an object's property where we want Spring to inject a value from the context

#### There are actually three ways that ```@Autowired``` can be used:
- Injection the value in the field of the class
- Injecting the value through the constructor parameters of the class
- Injecting the value through the setter

### Using ```@Autowired``` to inject the values through the class fields

*For this example imagine that you have two classes Person and Parrot and they have 'has-A' relationship as well as we have configuration class*

```java
@Component
public class Person {
    private String name = "Deni";
    // Using the @Autowired annotation over the field, we instruct Spring to provide a value for that field from its context
    @Autowired
    private Parrot Parrot;
}
```
*Keep in mind that this approach is not very desired in production code*
#### By injecting the value directly in the field:
- you dont have the option to make the field final, so make sure nobody changes its value after initialization
- it is more difficult to manage the value at initialization

### Using ```@Autowired``` to inject the values through the constructor

You can inject values into the object's attributes using the class' constructor defining the instance. *This approach is the most met in production code*

*This method allows you to define the dependency as final*
```java
@Component
public class Person {
    private String name = "Deni";
    private final Parrot parrot;

    // Sprign will provides a bean from tis context as a value to that parameter when calling the constructor 
    @Autowired
    public Person(Parrot parrot) {
        this.parrot = parrot;
    }
}
```

## Dealing with circular depedencies 

A circular depedency is a situation in which, to create a bean A Spring needs to inject another bean B that that doesnt exists yet, but bean B needs bean A, so Spring will be in a deadlock

*This is easy to be avoided, you just need to make sure you dont define objects whose creation depends on the other, having dependencies from one object to another like this is a bad idea*

![](https://image2url.com/r2/default/images/1771342644721-b97bcedd-d21e-4e66-ac45-6c998d5fcb23.png)

## Choosing from multiple beans in the Spring context

This section covers the scenarion in which Spring needs to inject a value into a parameter or class firled but has multiple beans of the same type to choose from

**If the names of the parameter matches the name of one of the beans in the context, Spring will choose the bean for which the name is the same as the parameter**

#### If the name of the parameter doens't match the name of a bean in the context, you would have the following options:
- You have marked one of the beans as ```@Primary```, in this case Spring will select the primary bean for the injection
- You can explicitly select a bean using the ```@Qualifier``` annotation
- If none of the beans is primary or there is no ```@Qualifier``` exception will be thrown

### Name of the parameter matches with a name of a bean
```java
@Configuration
public class ProjectConfig {
    @Bean
    public Parrot parrot1() {
        Parrot p = new Parrot();
        p.setName("Koko");
        return p;
    }

    @Bean
    public Parrot parrot2() {
        Parrot p = new Parrot();
        p.setName("Miki");
        return p;
    }

    @Bean
    // Spring will provide the value of the bean whose name is the same as the name of the parameter we defined
    public Person person(Parrot person2) {
        Person p = new Person();
        p.setName("Ella");
        p.setParrot(parrot2);
        return p;
    }
}
```
*This method is not very recommended since it could be easily refactored and changebd by mistake by another developr*

### Using the @Qualifier annotation
Instead of having a specific identifier of the parameter, now will be specified which bean we want to be injected using the value attribute of the ```@Qualifer``` annotation
```java
@Component
public class Person {
    private String name = "Deni";

    private final Parrot parrot;

    // Spring will inject here the beans with the name of parrot2 
    public Person(@Qualifer("parrot2") Parrot parrot) {
        this.parrot = parrot;
    }
}
```